{"version":3,"mappings":"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","names":["define","___default","urlUtil__default","checkStrategy","assetManagerFactory","assetManager","strategies","data","options","parseUrl","_strategies","addStrategy","prependStrategy","setStrategies","self","name","handle","setData","getData","resolve","resolved","inputUrl","cache","resolveBy","strategy","clearCache","prependToUrl","base","url","encodeURIComponent","packedUrl","type","baseUrl","itemCssNoCache","external","base64","taomedia","$__default","eventifier__default","assetManagerFactory__default","itemRunnerFactory","flow","init","done","pending","render","providerName","provider","suspended","closed","container","newData","initDone","filter","forEach","assets","contextData","assetManagerOptions","elt","renderDone","clear","clearDone","getState","setState","state","itemData","Promise","getOptions","setOptions","getResponses","renderFeedbacks","feedbacks","itemSession","suspend","close","resume","isSuspended","isClosed"],"sources":["../assets/manager.js","../assets/strategies.js","../runner/api/itemRunner.js","module-create.js"],"sourcesContent":["define('taoItems/assets/manager',['lodash', 'util/url'], function (_, urlUtil) { 'use strict';\n\n    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\n    var ___default = /*#__PURE__*/_interopDefaultLegacy(_);\n    var urlUtil__default = /*#__PURE__*/_interopDefaultLegacy(urlUtil);\n\n    /*\n     * This program is free software; you can redistribute it and/or\n     * modify it under the terms of the GNU General Public License\n     * as published by the Free Software Foundation; under version 2\n     * of the License (non-upgradable).\n     *\n     * This program is distributed in the hope that it will be useful,\n     * but WITHOUT ANY WARRANTY; without even the implied warranty of\n     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n     * GNU General Public License for more details.\n     *\n     * You should have received a copy of the GNU General Public License\n     * along with this program; if not, write to the Free Software\n     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n     *\n     * Copyright (c) 2015-2019 (original work) Open Assessment Technologies SA;\n     *\n     */\n\n    /**\n     * @typedef AssetStrategy Defines a way to resolve an asset path\n     * @property {String} name - the strategy name\n     * @property {assetStrategyHandle} handle - how to resolve the strategy.\n     */\n\n    /**\n     * @callback assetStrategyHandle\n     * @param {String|Object} url - the URL to resolved. If parseUrl, it's an object that contains host, port, search, queryString, etc.\n     * @param {Object} data - the context data\n     * @returns {String?} falsy if not resolved otherwise the resolved URL\n     */\n\n    /**\n     * Check if the given object is a valid AssetStrategy\n     * @param {AssetStrategy} strategy\n     * @throws {TypeError}\n     */\n    var checkStrategy = function checkStrategy(strategy) {\n        if (!___default['default'].isPlainObject(strategy) || !___default['default'].isFunction(strategy.handle) || !___default['default'].isString(strategy.name)) {\n            throw new TypeError('An asset resolution strategy is an object with a handle method and a name');\n        }\n    };\n\n    /**\n     * The assetManagerFactory create a new assetManager with the given resolution strategies and a data context.\n     *\n     * @example\n     *   //define AssetStrategies with a name and a handle method\n     *   var strategies = [{\n     *       name : 'external',\n     *       handle : function(url, data){\n     *           if(/^http/.test(url)){\n     *               return path;\n     *           }\n     *       }\n     *   }, {\n     *       name : 'relative',\n     *       handle : function(url, data){\n     *           if(/^((\\.\\/)|(\\w\\/))/){\n     *               return data.baseUrl + '/' + url ;\n     *           }\n     *       }\n     *   }]);\n     *\n     *   var assetManager = assetManagerFactory(strategies, { baseUrl : 'http://t.oa/public/assets/' });\n     *   assetManager.resolve('http://foo/bar.png'); //will resolved using external\n     *   assetManager.resolve('bar.png'); //will resolved using relative strategy\n     *\n     * @param {AssetStrategy[]} strategies - the strategies\n     * @param {Object} data - the context data\n     * @param {Object} [options] - the manager options\n     * @param {Boolean} [options.parseUrl = true] - If the URL to give to the strategies should be parsed or given as it is.\n     * @param {Boolean} [options.cache] - resolve the same URL only once and store the result in memory.\n     *\n     * @exports taoItems/assets/manager\n     * @namespace assetManagerFactory\n     * @returns {Object} Asset manager\n     */\n    var assetManagerFactory = function assetManagerFactory(strategies, data, options) {\n        var cache = {},\n            assetManager;\n\n        strategies = ___default['default'].isArray(strategies) ? strategies : [strategies];\n        data = data || {};\n        options = ___default['default'].defaults(options || {}, {\n            parseUrl: true\n        });\n\n        /**\n         * A brand new asset manager is created by the factory\n         */\n        assetManager = {\n            /**\n             * The stack of strategies that would be used to resolve the asset path\n             * @type {AssetStrategy[]}\n             */\n            _strategies: [],\n\n            /**\n             * Add an asset resolution strategy at the end of the stack.\n             * The strategies will be evaluated in the order they've been added.\n             * @param {AssetStrategy} strategy - the strategy to add\n             * @throws {TypeError} if the strategy isn't defined correctly\n             */\n            addStrategy: function addStrategy(strategy) {\n                checkStrategy(strategy);\n\n                this._strategies.push(strategy);\n            },\n\n            /**\n             * Add an asset resolution strategy at the beginning of the stack.\n             * The strategies will be evaluated in the order they've been added.\n             * @param {AssetStrategy} strategy - the strategy to add\n             * @throws {TypeError} if the strategy isn't defined correctly\n             */\n            prependStrategy: function prependStrategy(strategy) {\n                checkStrategy(strategy);\n\n                this._strategies.unshift(strategy);\n            },\n\n            /**\n             * Change the strategies\n             * @param {AssetStrategy[]} newStrategies - the strategies\n             * @throws {TypeError} if the strategy isn't defined correctly\n             */\n            setStrategies: function setStrategies(newStrategies) {\n                var self = this;\n\n                this._strategies = [];\n\n                //assign the strategies to the assetManager\n                ___default['default'].forEach(newStrategies, function(strategy) {\n                    //if it's an object we add it directly\n                    if (___default['default'].isPlainObject(strategy)) {\n                        assetManager.addStrategy(strategy);\n\n                        //if it's a function, we create the strategy with a generated name\n                    } else if (___default['default'].isFunction(strategy)) {\n                        self.addStrategy({\n                            name: `strategy_${self._strategies.length + 1}`,\n                            handle: strategy\n                        });\n                    }\n                });\n            },\n\n            /**\n             * Set context data\n             * @param {String|Object} [key] - the key of the data to set or the data values if it's an object\n             * @param {*} [value] - the value to set if a key is given\n             */\n            setData: function setData(key, value) {\n                if (___default['default'].isString(key) && typeof value !== 'undefined') {\n                    data[key] = value;\n                } else if (___default['default'].isPlainObject(key)) {\n                    data = key;\n                }\n            },\n\n            /**\n             * Get context data\n             * @param {String} [key] - if we want the value of a particular key\n             * @returns {Object|*} all the data or the propriety value if key is given\n             */\n            getData: function getData(key) {\n                if (___default['default'].isString(key)) {\n                    return data[key];\n                }\n                return data;\n            },\n\n            /**\n             * Resolve the given URL against the strategies\n             * @param {String} url - the URL to resolve\n             * @returns {String?} the resolved URL or nothing\n             */\n            resolve: function resolve(url) {\n                var resolved;\n                var inputUrl;\n\n                //if caching try to load the value from the cache\n                if (options.cache && typeof cache[url] !== 'undefined') {\n                    return cache[url];\n                }\n\n                //parse the URL ?\n                inputUrl = options.parseUrl ? urlUtil__default['default'].parse(url) : url;\n\n                //call strategies handlers, in their order until once returns something\n                ___default['default'].forEach(this._strategies, function(strategy) {\n                    var result = strategy.handle(inputUrl, data);\n                    if (result) {\n                        resolved = result;\n                        return false;\n                    }\n                });\n\n                resolved = resolved || '';\n\n                if (options.cache) {\n                    cache[url] = resolved;\n                }\n\n                return resolved;\n            },\n\n            /**\n             * Resolve the given URL against the strategy identified by the given name\n             * @param {String} name - the strategy name\n             * @param {String} url - the URL to resolve\n             * @returns {String?} the resolved URL or nothing\n             */\n            resolveBy: function resolveBy(name, url) {\n                var inputUrl;\n                var resolved = '';\n                var strategy = ___default['default'].find(this._strategies, { name: name });\n                if (strategy) {\n                    //parse the URL ?\n                    inputUrl = options.parseUrl ? urlUtil__default['default'].parse(url) : url;\n                    resolved = strategy.handle(inputUrl, data);\n                }\n                return resolved;\n            },\n\n            /**\n             * When the cache is used, it could be useful to clear the cache\n             */\n            clearCache: function clearCache() {\n                if (options.cache) {\n                    cache = {};\n                }\n            }\n        };\n\n        assetManager.setStrategies(strategies);\n\n        return assetManager;\n    };\n\n    return assetManagerFactory;\n\n});\n\n","define('taoItems/assets/strategies',['util/url', 'lodash'], function (urlUtil, _) { 'use strict';\n\n    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\n    var urlUtil__default = /*#__PURE__*/_interopDefaultLegacy(urlUtil);\n    var ___default = /*#__PURE__*/_interopDefaultLegacy(_);\n\n    /*\n     * This program is free software; you can redistribute it and/or\n     * modify it under the terms of the GNU General Public License\n     * as published by the Free Software Foundation; under version 2\n     * of the License (non-upgradable).\n     *\n     * This program is distributed in the hope that it will be useful,\n     * but WITHOUT ANY WARRANTY; without even the implied warranty of\n     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n     * GNU General Public License for more details.\n     *\n     * You should have received a copy of the GNU General Public License\n     * along with this program; if not, write to the Free Software\n     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n     *\n     * Copyright (c) 2015-2019 (original work) Open Assessment Technologies SA;\n     *\n     */\n\n    /**\n     * Prepend a base to an URL\n     * @param {Object} url - a parsed URL\n     * @param {String} base - the base to prepend\n     * @param {Boolean} [slashcat = false] - remove dots, double slashes, etc.\n     * @returns {String} the URL\n     */\n    var prependToUrl = function prependToUrl(url, base, slashcat) {\n        //is slashcat we manage slash concact\n        if (slashcat === true) {\n            return `${base.replace(/\\/$/, '')}/${url.directory.replace(/^\\.\\//, '').replace(/^\\//, '')}${encodeURIComponent(url.file.replace(/^\\.\\//, '').replace(/^\\//, ''))}`;\n        }\n\n        return base + url.directory.replace(/^\\.?\\//, '') + encodeURIComponent(url.file.replace(/^\\.?\\//, ''));\n    };\n\n    /**\n     * Unrelated strategies accessible by there name.\n     * Remember to not use the whole object, but each one in an array since the order matters.\n     *\n     * @exports taoItems/assets/strategies\n     */\n    var strategies = {\n        //the packedUrl will replace the asset with the url given in the assets part\n        //the assetManager should add the assets part to data with .setData('assets' itemData.content.assets)\n        packedUrl: {\n            name: 'packedUrl',\n            handle: function handlePackedUrl(url, data) {\n                var type;\n                if (!___default['default'].isUndefined(url.source) && !___default['default'].isUndefined(data.assets)) {\n                    type = ___default['default'].findKey(data.assets, url.source);\n                    if (type && urlUtil__default['default'].isAbsolute(data.assets[type][url.source])) {\n                        return data.assets[type][url.source];\n                    }\n                }\n            }\n        },\n        //the baseUrl concats the baseUrl in data if the url is relative\n        baseUrl: {\n            name: 'baseUrl',\n            handle: function handleBaseUrl(url, data) {\n                if (typeof data.baseUrl === 'string' && urlUtil__default['default'].isRelative(url)) {\n                    return prependToUrl(url, data.baseUrl, data.slashcat);\n                }\n            }\n        },\n\n        //bust the cache for item CSS\n        itemCssNoCache: {\n            name: 'itemCssNoCache',\n            handle: function handleItemCss(url, data) {\n                if (typeof data.baseUrl === 'string' && urlUtil__default['default'].isRelative(url) && /\\.css$/.test(url.file)) {\n                    return urlUtil__default['default'].build(prependToUrl(url, data.baseUrl, data.slashcat), { bust: Date.now() });\n                }\n            }\n        },\n\n        //absolute URL are just left intact\n        external: {\n            name: 'external',\n            handle: function handleExternal(url) {\n                if (urlUtil__default['default'].isAbsolute(url)) {\n                    return url.toString();\n                }\n            }\n        },\n\n        //the base64 encoded resources are also left intact\n        base64: {\n            name: 'base64',\n            handle: function handleB64(url) {\n                if (urlUtil__default['default'].isBase64(url)) {\n                    return url.toString();\n                }\n            }\n        },\n\n        //special tao media protocol\n        taomedia: {\n            name: 'taomedia',\n            handle: function handleTaoMedia(url, data) {\n                //either a baseUrl is given or if empty, taomedia resources are managed as relative resources\n                var baseUrl = data.baseUrl || './';\n                if ((typeof url === 'object' && url.protocol === 'taomedia') || /^taomedia:\\/\\//.test(url.toString())) {\n                    return baseUrl + url.toString();\n                }\n            }\n        }\n    };\n\n    return strategies;\n\n});\n\n","define('taoItems/runner/api/itemRunner',['jquery', 'core/eventifier', 'taoItems/assets/manager'], function ($, eventifier, assetManagerFactory) { 'use strict';\n\n    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\n    var $__default = /*#__PURE__*/_interopDefaultLegacy($);\n    var eventifier__default = /*#__PURE__*/_interopDefaultLegacy(eventifier);\n    var assetManagerFactory__default = /*#__PURE__*/_interopDefaultLegacy(assetManagerFactory);\n\n    /*\n     * This program is free software; you can redistribute it and/or\n     * modify it under the terms of the GNU General Public License\n     * as published by the Free Software Foundation; under version 2\n     * of the License (non-upgradable).\n     *\n     * This program is distributed in the hope that it will be useful,\n     * but WITHOUT ANY WARRANTY; without even the implied warranty of\n     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n     * GNU General Public License for more details.\n     *\n     * You should have received a copy of the GNU General Public License\n     * along with this program; if not, write to the Free Software\n     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n     *\n     * Copyright (c) 2014-2021 (original work) Open Assessment Technlogies SA (under the project TAO-PRODUCT);\n     *\n     */\n\n    /**\n     *\n     * Builds a brand new {@link itemRunner}.\n     *\n     * <strong>The factory is an internal mechanism to create encapsulated contexts.\n     *  I suggest you to use directly the name <i>itemRunner</i> when you require this module.</strong>\n     *\n     * @example require(['itemRunner'], function(itemRunner){\n     *            itemRunner({itemId : 12})\n     *                    .on('statechange', function(state){\n     *\n     *                    })\n     *                    .on('ready', function(){\n     *\n     *                    })\n     *                    .on('response', function(){\n     *\n     *                    })\n     *                   .init()\n     *                   .render($('.item-container'));\n     *          });\n     *\n     * @exports itemRunner\n     * @namespace itemRunnerFactory\n     *\n     * @param {String} [providerName] - the name of a provider previously registered see {@link itemRunnerFactory#register}\n     * @param {Object} [data] - the data of the item to run\n     * @param {Object} [options]\n     *\n     * @returns {itemRunner}\n     */\n    const itemRunnerFactory = function itemRunnerFactory(providerName, data = {}, options = {}) {\n        //flow structure to manage sync calls in an async context.\n        const flow = {\n            init: {\n                done: false,\n                pending: []\n            },\n            render: {\n                done: false,\n                pending: []\n            }\n        };\n\n        //optional params based on type\n        if (typeof providerName === 'object') {\n            data = providerName;\n            providerName = void 0;\n        }\n\n        /*\n         * Select the provider\n         */\n        const providers = itemRunnerFactory.providers;\n\n        //check a provider is available\n        if (!providers || Object.keys(providers).length === 0) {\n            throw new Error('No provider registered');\n        }\n\n        let provider;\n\n        if (typeof providerName === 'string' && providerName.length > 0) {\n            provider = providers[providerName];\n        } else if (Object.keys(providers).length === 1) {\n            //if there is only one provider, then we take this one\n            providerName = Object.keys(providers)[0];\n            provider = providers[providerName];\n        }\n\n        //now we should have a provider\n        if (!provider) {\n            throw new Error('No candidate found for the provider');\n        }\n\n        //set up a default assetManager using a \"do nothing\" strategy\n        const assetManager =\n            options.assetManager ||\n            assetManagerFactory__default['default'](function defaultStrategy(url) {\n                return url.toString();\n            });\n\n        let suspended = false;\n        let closed = false;\n\n        /**\n         * The itemRunner\n         * @typedef {Object} itemRunner\n         */\n\n        /**\n         * @type {itemRunner}\n         * @lends itemRunnerFactory\n         */\n        return eventifier__default['default']({\n            /**\n             * Items container\n             * @type {HTMLElement}\n             */\n            container: null,\n\n            /**\n             * The asset manager used to resolve asset\n             * @see taoItems/asset/manager\n             * @type {AssetManager}\n             */\n            assetManager,\n\n            /**\n             * To give options to the item runner provider\n             * @type {Object}\n             */\n            options,\n\n            /**\n             * Initialize the runner.\n             * @param {Object} [newData] - just in case you want to change item data (it should not occurs in most case)\n             * @returns {itemRunner} to chain calls\n             *\n             * @fires itemRunner#init\n             */\n            init(newData) {\n                /**\n                 * Call back when init is done\n                 */\n                const initDone = () => {\n                    //manage pending tasks the first time\n                    if (flow.init.done === false) {\n                        flow.init.done = true;\n\n                        flow.init.pending\n                            .filter(pendingTask => typeof pendingTask === 'function')\n                            .forEach(pendingTask => pendingTask());\n\n                        flow.init.pending = [];\n                    }\n\n                    /**\n                     * the runner has initialized correclty the item\n                     * @event itemRunner#init\n                     */\n                    this.trigger('init');\n                };\n\n                //merge data\n                if (newData) {\n                    data = Object.assign(data, newData);\n                }\n\n                if (typeof provider.init === 'function') {\n                    /**\n                     * Calls provider's initialization with item data.\n                     * @callback InitItemProvider\n                     * @param {Object} data - the item data\n                     * @param {Function} done - call once the initialization is done\n                     */\n                    provider.init.call(this, data, initDone);\n                } else {\n                    initDone();\n                }\n\n                return this;\n            },\n\n            /**\n             * Configure the assetManager\n             * @see taoItems/assets/manager\n             * @param {AssetStrategy[]} strategies - the resolving strategies\n             * @param {Object} [contextData] - the context data\n             * @param {Object} [assetManagerOptions] - the asset manager options\n             * @returns {itemRunner} to chain calls\n             */\n            assets(strategies, contextData, assetManagerOptions) {\n                try {\n                    this.assetManager = assetManagerFactory__default['default'](strategies, contextData, assetManagerOptions);\n                } catch (err) {\n                    this.trigger(\n                        'error',\n                        new Error(`Something was wrong while configuring the asset manager : ${err.message}`)\n                    );\n                }\n\n                return this;\n            },\n\n            /**\n             * Initialize the current item.\n             *\n             * @param {HTMLElement|jQueryElement} elt - the DOM element that is going to contain the rendered item.\n             * @param {Object} [newOptions] - to update the runner options\n             * @returns {itemRunner} to chain calls\n             *\n             * @fires itemRunner#ready\n             * @fires itemRunner#render\n             * @fires itemRunner#error if the elt isn't valid\n             *\n             * @fires itemRunner#statechange the provider is reponsible to trigger this event\n             * @fires itemRunner#responsechange  the provider is reponsible to trigger this event\n             */\n            render(elt, newOptions = {}) {\n                /**\n                 * Call back when render is done\n                 */\n                const renderDone = () => {\n                    //manage pending tasks the first time\n                    if (flow.render.done === false) {\n                        flow.render.done = true;\n\n                        flow.render.pending\n                            .filter(pendingTask => typeof pendingTask === 'function')\n                            .forEach(pendingTask => pendingTask());\n\n                        flow.render.pending = [];\n                    }\n\n                    /**\n                     * The item is rendered\n                     * @event itemRunner#render\n                     */\n                    this.trigger('render');\n\n                    /**\n                     * The item is ready.\n                     * Alias of {@link itemRunner#render}\n                     * @event itemRunner#ready\n                     */\n                    this.trigger('ready');\n                };\n\n                options = Object.assign(options || {}, newOptions);\n                if (!options.state) {\n                    options.state = {};\n                }\n\n                //check elt\n                if (!(elt instanceof HTMLElement) && !(elt instanceof $__default['default'])) {\n                    return this.trigger(\n                        'error',\n                        new Error('A valid HTMLElement (or a jquery element) at least is required to render the item')\n                    );\n                }\n\n                //set item state to restore item state after rendering if the provider enables it\n                if (options.state) {\n                    this.setState(options.state, true);\n                }\n\n                if (flow.init.done === false) {\n                    flow.init.pending.push(() => this.render(elt, options));\n                } else {\n                    //we keep a reference to the container\n                    if (elt instanceof $__default['default']) {\n                        this.container = elt.get(0);\n                    } else {\n                        this.container = elt;\n                    }\n\n                    //the state will be applied only when the rendering is made\n\n                    if (typeof provider.render === 'function') {\n                        /**\n                         * Calls the provider's render\n                         * @callback RendertItemProvider\n                         * @param {HTMLElement} elt - the element to render inside\n                         * @param {Function} done - call once the render is done\n                         * @param {Object} [options] - the array of options that the item runner provider may supports\n                         * @param {Object} [options.state] - pass initial item state to method render() in case the item runner provider require initial state to render\n                         */\n                        provider.render.call(this, this.container, renderDone, options);\n                    } else {\n                        renderDone();\n                    }\n                }\n\n                return this;\n            },\n\n            /**\n             * Clear the running item.\n             * @returns {itemRunner}\n             *\n             * @fires itemRunner#clear\n             */\n            clear() {\n                /**\n                 * Call back when clear is done\n                 */\n                const clearDone = () => {\n                    /**\n                     * The item is ready.\n                     * @event itemRunner#clear\n                     */\n                    this.trigger('clear');\n                };\n\n                if (typeof provider.clear === 'function') {\n                    /**\n                     * Calls the provider's clear\n                     * @callback ClearItemProvider\n                     * @param {HTMLElement} elt - item's container\n                     * @param {Function} done - call once the initialization is done\n                     */\n                    provider.clear.call(this, this.container, clearDone);\n                } else {\n                    clearDone();\n                }\n\n                return this;\n            },\n\n            /**\n             * Get the current state of the running item.\n             *\n             * @returns {Object|Null} state\n             */\n            getState() {\n                if (typeof provider.getState === 'function') {\n                    /**\n                     * Calls the provider's getState\n                     * @callback GetStateItemProvider\n                     * @returns {Object} the state\n                     */\n                    return provider.getState.call(this);\n                }\n                return null;\n            },\n\n            /**\n             * Set the current state of the running item.\n             * This should have the effect to restore the item state.\n             *\n             * @param {Object} state - the new state\n             * @param {boolean} [isInitialStateRestore] - state restoring or not\n             * @returns {itemRunner}\n             *\n             * @fires itemRunner#error if the state type doesn't match\n             */\n            setState(state, isInitialStateRestore = false) {\n                if (!state || typeof state !== 'object' || Array.isArray(state)) {\n                    return this.trigger(\n                        'error',\n                        new Error(`The item's state must be a JavaScript Plain Object: ${typeof state} given`)\n                    );\n                }\n\n                //the state will be applied only when the rendering is made\n                if (flow.render.done === false) {\n                    flow.render.pending.push(() => this.setState(state, isInitialStateRestore));\n                } else if (typeof provider.setState === 'function') {\n                    /**\n                     * Calls the provider's setState\n                     * @callback SetStateItemProvider\n                     * @param {Object} state -  the state to set\n                     */\n                    provider.setState.call(this, state, isInitialStateRestore);\n                }\n                return this;\n            },\n\n            /**\n             * Get the item data.\n             *\n             * @returns {Object} the item's data\n             */\n            getData() {\n                return data;\n            },\n\n            /**\n             * Replaces item data in rendered item\n             * @param {object} itemData\n             * @returns {Promise}\n             */\n            setData(itemData) {\n                data = itemData;\n                if (typeof provider.setData === 'function') {\n                    return provider.setData.call(this, itemData);\n                }\n                return Promise.resolve();\n            },\n\n            /**\n             * Get the item runner options.\n             *\n             * @returns {Object} the item rendering options\n             */\n            getOptions() {\n                return this.options;\n            },\n\n            /**\n             * Replaces item runner's options.\n             * @param {Object} newOptions - the options to set\n             * @returns {Promise}\n             */\n            setOptions(newOptions = {}) {\n                this.options = newOptions;\n                if (typeof provider.setOptions === 'function') {\n                    return provider.setOptions.call(this, this.options);\n                }\n                return Promise.resolve();\n            },\n\n            /**\n             * Get the responses of the running item.\n             *\n             * @returns {Object} the item's responses\n             */\n            getResponses() {\n                if (typeof provider.getResponses === 'function') {\n                    /**\n                     * Calls the provider's getResponses\n                     * @callback GetResponsesItemProvider\n                     * @returns {Object} the responses\n                     */\n                    return provider.getResponses.call(this);\n                }\n                return {};\n            },\n\n            /**\n             * Append the modalFeedbacks into the item and create queue of feedbacks that should be displayed to the user\n             *\n             * @param {Object|Array} feedbacks - all feedbacks of the item\n             * @param {Object|Array} itemSession - determine feedbacks which should be displayed\n             * @param {function} done - runs after loading feedbacks into the item\n             *      # have parameter {Object|Array} renderingQueue with prepared queue of the feedbacks for displaying to the user\n             *\n             *\n             * Example:\n             *\n             *    this.renderFeedbacks({f1: 'feedback1', f2: 'feedback2', f3: 'feedback3'}, ['f2'], function(renderingQueue){\n             *      renderingQueue; // {'feedback2'}\n             *    });\n             */\n            renderFeedbacks(feedbacks, itemSession, done) {\n                if (typeof provider.renderFeedbacks === 'function') {\n                    provider.renderFeedbacks.call(this, feedbacks, itemSession, done);\n                }\n            },\n\n            /**\n             * Call the provider's suspend method\n             * @returns {Promise}\n             */\n            suspend() {\n                if (!suspended && flow.render.done && typeof provider.suspend === 'function') {\n                    return provider.suspend.call(this).then(result => {\n                        suspended = true;\n                        return result;\n                    });\n                }\n                return Promise.resolve();\n            },\n\n            /**\n             * Call the provider's hide method\n             * @returns {Promise}\n             */\n            close() {\n                if (!closed && flow.render.done && typeof provider.close === 'function') {\n                    return provider.close.call(this).then(result => {\n                        closed = true;\n                        return result;\n                    });\n                }\n                return Promise.resolve();\n            },\n\n            /**\n             * Call the provider's resume method.\n             * We can resume a previously suspended or closed item.\n             * @returns {Promise}\n             */\n            resume() {\n                if ( (suspended || closed) && flow.render.done && typeof provider.resume === 'function') {\n                    return provider.resume.call(this).then(result => {\n                        suspended = false;\n                        closed = false;\n                        return result;\n                    });\n                }\n                return Promise.resolve();\n            },\n\n            /**\n             * Is the item runner suspended\n             * @returns {boolean} true if suspended\n             */\n            isSuspended() {\n                return suspended;\n            },\n\n            /**\n             * Is the item runner closed\n             * @returns {boolean} true if closed\n             */\n            isClosed(){\n                return closed;\n            },\n        });\n    };\n\n    /**\n     * Register an <i>Item Runtime Provider</i> into the item runner.\n     * The provider provides the behavior required by the item runner.\n     *\n     * @param {String} name - the provider name will be used to select the provider while instantiating the runner\n     *\n     * @param {Object} provider - the Item Runtime Provider as a plain object. The itemRunner forwards encapsulate and delegate calls to the provider.\n     * @param {InitItemProvider} provider.init - the provider initializes the item from it's data, for example loading libraries, add some listeners, etc.\n     * @param {RenderItemProvider} provider.render - the provider renders the item within the given container element.\n     * @param {ClearItemProvider} [provider.clear] - the provider clears the item.\n     * @param {GetStateItemProvider} [provider.getState] - the provider get the item's state.\n     * @param {SetStateItemProvider} [provider.setState] - the provider restore the item to the given state.\n     * @param {GetRespnsesItemProvider} [provider.getResponses] - the provider gives the current responses.\n     *\n     * @throws TypeError when a wrong provider is given or an empty name.\n     */\n    itemRunnerFactory.register = function registerProvider(name, provider) {\n        //type checking\n        if (typeof name !== 'string' || name.length <= 0) {\n            throw new TypeError('It is required to give a name to your provider.');\n        }\n        if (\n            typeof provider !== 'object' ||\n            (typeof provider.init !== 'function' && typeof provider.render !== 'function')\n        ) {\n            throw new TypeError('A provider is an object that contains at least an init function or a render function.');\n        }\n\n        this.providers = this.providers || {};\n        this.providers[name] = provider;\n    };\n\n    return itemRunnerFactory;\n\n});\n\n","\ndefine(\"taoItems/loader/taoItemsRunner.bundle\", function(){});\n"]}